# Project Context

## Purpose
Provide a zero-config bridge that lets Cargo users build Rust workspaces with Buck2. Buckal auto-generates Buck2 rules from Cargo metadata, so teams can keep the familiar Cargo workflow while gaining Buck2's performance and scalability.

## Tech Stack
- Rust (edition 2024) for the `cargo-buckal` CLI and core logic
- Buck2 as the build engine; custom Starlark rules and Python helpers live in `buckal-bundles`
- Cargo as the package manager and source of dependency metadata
- GitHub-hosted bundle repo `buck2hub/buckal-bundles` (fetched via the GitHub API, falls back to a pinned hash)

## Project Conventions

### Code Style
- Rustfmt defaults and Clippy lints before submitting changes
- Modules mirror concerns: `commands/*` for each CLI subcommand, `buckify` for rule generation, `bundles` for Buck2 cell wiring
- Prefer explicit error handling with `anyhow` plus `UnwrapOrExit` helpers for user-facing errors
- Keep generated files tagged with `# @generated by cargo buckal`

### Architecture Patterns
- Four layers: CLI (clap-based commands) → Snapshot/cache (fingerprints and diffs) → Core buckify (resolver, rule emitter/patcher) → Prelude/bundles (Starlark rules such as `cargo_manifest`, `rust_library`, `rust_binary`, `buildscript_run`)
- CLI commands translate user intent into dependency-graph changes; snapshot layer diffs and triggers incremental BUCK updates instead of full regeneration
- Buck2 integration is through an external `buckal` cell added to `.buckconfig`, pointing to the pinned bundle commit; Buck2 CLI wrapper centralizes invocations and verbosity handling
- Vendor layout defaults to `third-party/rust/crates`, keeping generated BUCK targets colocated with vendored sources

### Testing Strategy
- No automated tests are present yet; rely on manual runs of `cargo buckal build`/`add`/`migrate` against sample workspaces
- When adding tests, favor integration tests that compare generated BUCK files/targets and smoke tests that execute Buck2 builds
- Run `cargo fmt && cargo clippy` (and `cargo test` once tests exist) before sending changes

### Git Workflow
- Contributions flow through GitHub repos (`buck2hub/cargo-buckal`, `buck2hub/buckal-bundles`); use short-lived feature branches and PR review
- Commit messages in imperative mood; keep changes scoped (e.g., one CLI subcommand or bundle rule tweak per PR)
- Avoid rewriting unrelated generated BUCK files; rely on incremental buckify to minimize diffs

## Domain Context
- Addresses shortcomings of Cargo alone for large Rust monorepos by delegating builds to Buck2 while retaining Cargo's dependency management
- Replaces manual BUCK authoring/reindeer workflows with one-step commands (`cargo buckal add/build/migrate/new`) and zero-config migration
- Bundles supply Buck2 rules tailored for Cargo semantics, including build script support and platform/cfg handling

## Important Constraints
- Requires a Buck2 binary available on PATH or configured in `~/.config/buckal/config.toml`
- `.buckconfig` is mutated to register the external `buckal` cell and to ignore `.buckal`, `buck-out`, and `target`
- Network access to GitHub improves bundle freshness; if unavailable, a pinned default hash is used
- Generated artifacts and vendor directory live under `third-party/rust/crates`; keep this path stable to avoid cache invalidations
- Strive for zero manual edits to generated BUCK files—changes should flow from Cargo metadata and buckify logic

## External Dependencies
- Buck2 runtime and tooling
- GitHub API (used to fetch latest commit for `buckal-bundles`)
- Python runtime for bundle helper scripts executed by Buck2
- Cargo registry/crates.io for dependency resolution (handled by Cargo, not Buck2)
